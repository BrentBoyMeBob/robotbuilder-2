# Logical Structure

Subsystems are collections of _actuators_ and _sensors_. Actuators are used to define _actions_, which change some
state in the physical world such as turning a wheel or extending a piston. Sensors are used to define _states_ that
the subsystem may be in at any particular time.  From _actions_ and _states_, we can define _commands_ that will
run an _action_ until some _state_ is reached, at which point the _command_ has finished its task and will cease
execution.  Each subsystem may only have a single command running at a time.  If a new command is scheduled while
another is already running, the running command will be stopped early so the new command can start executing.

Commands can be composed into larger _command groups_ which define an order in which other commands
will run; commands in a group may be from different subsystems to accomplish some higher-level task that is
out of reach for a single subsystem to accomplish.


```java
/**
 * This entire file was autogenerated! Or at least, it COULD be.
 */
public class Drivebase extends SubsystemBase {
  // ACTUATORS 
  private final MotorController leftMotor, rightMotor;

  // SENSORS
  private final Gyro gyro;

  // CONTROLS
  private final DifferentialDrive drive;
  private final DifferentialDriveOdometry odometry;
  private final ProfiledPIDController turningController;

  public Drivebase(MotorController leftMotor, MotorController rightMotor, Gyro gyro) {
    this.leftMotor = leftMotor;
    this.rightMotor = rightMotor;
    this.gyro = gyro;

    this.drive = new DifferentialDrive(leftMotor, rightMotor);
    this.odometry = new DifferentialDriveOdometry(new Rotation2d(), 0, 0);

    this.turningController = new ProfiledPIDController(1, 0, 0, new TrapezoidProfile.Constraints(1, 5));
    this.turningController.enableContinuousInput(0, 360);
    this.turningController.setTolerance(1); // degree
  }

  // ACTIONS

  public void stop() {
    this.drive.stopMotors();
  }

  // Note that this action is /parameterized/ - any command would need to either hardcode
  // values or accept suppliers for them
  public void tankDrive(double leftSpeed, double rightSpeed) {
    this.drive.tankDrive(leftSpeed, rightSpeed);
  }

  public void turnToTargetAngle() {
    double turnSpeed = this.turningController.calculate(this.gyro.getAngle());
    this.drive.arcadeDrive(0, turnSpeed, false);
  }

  // HOUSEKEEPING

  public void setTargetAngle(double targetAngleDegrees) {
    this.turningController.reset(this.gyro.getAngle());
    this.turningController.setGoal(targetAngleDegrees);
  }

  // STATES

  public boolean atTargetAngle() {
    return this.turningController.atGoal();
  }

  public double getAngle() {
    return this.gyro.getAngle();
  }

  // COMMANDS

  public Command stopCommand() {
    return this.runOnce(this::stop); // ACTION
  }

  public Command driveStraightCommand() {
    return this.run(() -> this.tankDrive(1, 1)); // ACTION (hardcoded parameters)
  }

  public Command driveAtSpeedCommand(double leftSpeed, double rightSpeed) {
    return this.run(() -> this.tankDrive(leftSpeed, rightSpeed)); // ACTION (pass-through parameters)
  }
 
  public Command tankDriveCommand(DoubleSupplier leftSpeed, DoubleSupplier rightSpeed) {
    return this.run(() -> this.tankDrive(leftSpeed.getAsDouble(), rightSpeed.getAsDouble()); // ACTION (supplied parameters)
  }

  public Command rotateBy90DegreesCommand() {
    // not ideal - builds a sequential group 
    return this.runOnce(() -> setTargetAngle(getAngle() + 90)) // HOUSEKEEPING
               .andThen(run(this::turnToTargetAngle).until(this::atTargetAngle)) // ACTION, STATE
               .finallyDo((interrupted) -> this.stop()); // ACTION

    // or:

    // works, but doesn't follow the fluent API
    return new FunctionalCommand(
      () -> setTargetAngle(getAngle() + 90),
      this::turnToTargetAngle,
      (interrupted) -> this.stop(),
      this::atTargetAngle,
      this
    );

    // OR OR:

    // hypothetical additions to the fluent API
    return this.firstDo(() -> setTargetAngle(getAngle() + 90)) // HOUSEKEEPING
               .thenRun(this::turnToTargetAngle) // ACTION (repeatable)
               .until(this::atTargetAngle) // STATE
               .doWhenFinished(this::stop); // ACTION (one-off)
  }
}
```



## Actuators

An actuator is a physical device with which a robot can interact with the physical world.



## Sensors

Sensors are devices that provide a robot with information about the physical world. Many sensors provide some type of
*proprioceptive* feedback about the state of some part of the robot - for example, how fast a motor is spinning or
the position of an actuator. Such sensors are typically an electric or electronic device that plugs directly into
a header on the control board and outputs an analog or digital signal that can be interpreted as a value.

Computer vision is also a form of sensor, though not in the form that most people are familiar with.  Vision pipelines
take an image from a camera and extract some useful information out of it, such as the position of a game piece or
scoring location, and allow that information to be accessed.  A concrete example would be a vision pipeline that
detects the location of a game piece on the floor and outputs the angle to its center; the robot program can then
take that angle and turn left or right until its intake is aligned with the game piece, then move to pick it up. Or
a vision pipeline detects AprilTags on the field and outputs the robot's estimated location and pose in 3D space, which
can be used to automatically plan a complex path to move the robot to a know position on the field.



## Commands

There are three types of command:
- Atomic
- Parallel groups
- Sequential groups

Atomic commands require a single subsystem and perform a single action with that subsystem until some end state is
reached.  They can run forever (or until interrupted by another command) - useful for manual control, for a set
amount of time, or until their subsystem has reached the target state of the command, at which point they end
automatically.

Parallel groups are sets of other commands that run concurrently.  A parallel group may complete after *all* commands
in that group have finished naturally, after *any* commands has finished naturally, or after a *specific* command
has finished naturally.

Sequential groups are sets of commands that run one after the other.  Each command in the group will run until its
natural completion, after which the next command in the sequence will start.  The group command itself will finish
naturally after the final command in the sequence completes.



## Housekeeping

How to define a command that performs a *delta* change, i.e. not moving to a preset location but to one that's relative
to the current state of its subsystem?

```java
public Command rotateBy90DegreesCommand() {
  return this.runOnce(() -> setTargetAngle(getAngle() + 90)) // HOUSEKEEPING
             .andThen(run(this::turnToTargetAngle).until(this::atTargetAngle)) // ACTION, STATE
             .finallyDo(this::stop); // ACTION
}
```

This is where _housekeeping_ comes into play.  This is used to clean up state or provide one-time input to a controller
that uses its own internal state to generate values for use by the subsystem.


## Hints

Components can provide _hints_ for how they can be used.  These hints are used by the UI to suggest binding options -
for example, creating a new action called "drive" taking two parameters "left" and "right" could match a hint by a
DifferentialDrive component's "tankDrive" method.  A user accepting the hint would cause the code generator to
implement the method to pass the parameters of the subsystem's `drive` method to the `tankDrive` method on its
DifferentialDrive.

Various methods on components can be tagged for support for actions, states, or housekeeping items; if a method
is tagged, it will appear higher on the list of suggestions than if it weren't (it may not even appear without a tag).

```json
// Hypothetical DifferentialDrive component definition
{
  "name": "Differential Drive",
  "fqn": "edu.wpi.first.wpilibj.drive.DifferentialDrive",
  "className": "DifferentialDrive",
  "hints": [
    "action"
  ],
  "constructor": {
    "params": [
      {
        "name": "leftMotor",
        "type": "MotorController"
      },
      {
        "name": "rightMotor",
        "type": "MotorController"
      }
    ]
  },
  "methods": [
    {
      "name": "arcadeDrive",
      "hints": [
        "action"
      ],
      "params": [
        {
          "name": "xSpeed",
          "type": "double",
          "tags": [
            "x",
            "speed",
            "forward"
          ]
        },
        {
          "name": "zRotation",
          "type": "double",
          "tags": [
            "z",
            "rotation",
            "curve"
          ]
        },
        {
          "name": "squaredInputs",
          "type": "boolean",
          "optional": true,
          "tags": [
            "square"
          ]
        }
      ]
    }
  ]
}
```

```json
// Hypothetical PID controller definition
{
  "name": "PID Controller",
  "fqn": "edu.wpi.first.math.controller.PIDController",
  "className": "PIDController",
  "hints": [
    "action",
    "state",
    "housekeeping"
  ],
  "methods": [
    {
      "name": "setSetpoint",
      "hints": [
        "housekeeping"
      ],
      "returns": "void",
      "params": [
        {
          "name": "setpoint",
          "type": "double",
          "tags": [
            "setpoint"
          ]
        }
      ],
      "beforeCalling": "reset"
    },
    {
      "name": "getSetpoint",
      "hints": [
        "housekeeping"
      ],
      "returns": "double",
      "params": []
    },
    {
      "name": "atSetpoint",
      "hints": [
        "state"
      ],
      "returns": "boolean",
      "params": []
    },
    {
      "name": "calculate",
      "hints": [
        "action"
      ],
      "returns": "double",
      "params": [
        {
          "name": "measurement",
          "type": "double",
          "tags": [
            "current"
          ]
        }
      ]
    },
    {
      "name": "reset",
      "hints": [
        "housekeeping"
      ],
      "returns": "void",
      "params": []
    }
  ]
}
```